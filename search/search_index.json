{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>This is a continuation of my original contribution of a reworked Docker/Compose system for Pixelfed.</p> <p>This project is consolidating the original work, planned improvements, and documentation into one place, where I and hopefully others, can freely iterate and improve on the Pixelfed + Docker experience.</p> <p>It's still in the early setup and consolidation phase, so some things might link incorrectly or have out of date information.</p> <p>See the WIP v3 migration doc for more information</p>"},{"location":"conventions/","title":"Conventions","text":"<p>This section explains several conventions used in this documentation.</p>"},{"location":"conventions/#symbols","title":"Symbols","text":"<p>This documentation use some symbols for illustration purposes. Before you read on, please make sure you've made yourself familiar with the following list of conventions:</p>"},{"location":"conventions/#version","title":"\u2013 Version","text":"<p>The tag symbol in conjunction with a version number denotes when a specific feature or behavior was added. Make sure you're at least on this version if you want to use it.</p>"},{"location":"conventions/#default","title":"\u2013 Default value","text":"<p>Some properties in <code>.env</code> have default values for when the author does not explicitly define them. The default value of the property is always included.</p>"},{"location":"conventions/#default","title":"\u2013 Default value is computed","text":"<p>Some default values are not set to static values but computed from other values, like the site language, repository provider, or other settings.</p>"},{"location":"conventions/#default","title":"\u2013 Default value is empty","text":"<p>Some properties do not contain default values. This means that the functionality that is associated with them is not available unless explicitly enabled.</p>"},{"location":"conventions/#experimental","title":"\u2013 Experimental","text":"<p>Some newer features are still considered experimental, which means they might (although rarely) change at any time, including their complete removal (which hasn't happened yet).</p>"},{"location":"conventions/#required","title":"\u2013 Required value","text":"<p>Some (very few in fact) properties or settings are required, which means the authors must explicitly define them.</p>"},{"location":"conventions/#customization","title":"\u2013 Customization","text":"<p>This symbol denotes that the thing described is a customization that must be added by the author.</p>"},{"location":"customize/build-settings/","title":"Build settings","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p> <p>Most of these build arguments is configurable in your <code>.env</code> file when using the <code>docker-compose.yml</code> from Pixelfed!</p> <p>The Pixelfed Dockerfile utilizes Docker Multi-stage builds and Build arguments.</p> <p>Using build arguments allows us to create a flexible and more maintainable Dockerfile, supporting multiple runtimes (Nginx and Apache + mod_php) and end-user flexibility without having to fork or copy the Dockerfile.</p> <p>Build arguments can be configured using <code>--build-arg 'name=value'</code> for <code>docker build</code>, <code>docker compose build</code> and <code>docker buildx build</code>. For <code>docker-compose.yml</code>, the <code>args</code> key for <code>build</code> can be used.</p> <p>Most settings have two names in the title. The first one is the build arg name (<code>--build-arg</code>) and the second is the name in your <code>.env</code> file when using Docker Compose</p>"},{"location":"customize/build-settings/#php_version","title":"<code>PHP_VERSION</code>","text":"<p>Named <code>DOCKER_APP_PHP_VERSION</code> in your <code>.env</code> file</p> <p>The <code>PHP</code> version to use when building the runtime container.</p> <p>Any valid Docker Hub PHP version is acceptable here, as long as it's published to Docker Hub</p> <p>Example values:</p> <ul> <li><code>8</code> will use the latest version of PHP 8</li> <li><code>8.1</code> will use the latest version of PHP 8.1</li> <li><code>8.2.14</code> will use PHP 8.2.14</li> <li><code>latest</code> will use whatever is the latest PHP version</li> </ul> <p>Default value: <code>8.1</code></p>"},{"location":"customize/build-settings/#php_pecl_extensions","title":"<code>PHP_PECL_EXTENSIONS</code>","text":"<p>PECL extensions to install via <code>pecl install</code></p> <p>Use PHP_PECL_EXTENSIONS_EXTRA if you want to add additional extenstions.</p> <p>Only change this setting if you want to change the baseline extensions.</p> <p>See the <code>PECL extensions</code> documentation on Docker Hub for more information.</p> <p>Default value: <code>imagick redis</code></p>"},{"location":"customize/build-settings/#php_pecl_extensions_extra","title":"<code>PHP_PECL_EXTENSIONS_EXTRA</code>","text":"<p>Named <code>DOCKER_APP_PHP_PECL_EXTENSIONS_EXTRA</code> in your <code>.env</code> file</p> <p>Extra PECL extensions (separated by space) to install via <code>pecl install</code></p> <p>See the <code>PECL extensions</code> documentation on Docker Hub for more information.</p> <p>Default value: <code>\"\"</code></p>"},{"location":"customize/build-settings/#php_extensions","title":"<code>PHP_EXTENSIONS</code>","text":"<p>PHP Extensions to install via <code>docker-php-ext-install</code>.</p> <p>NOTE: use <code>PHP_EXTENSIONS_EXTRA</code> if you want to add additional extensions; only override this if you're going to change the baseline extensions.</p> <p>See the <code>How to install more PHP extensions</code> documentation on Docker Hub for more information</p> <p>Default value: <code>intl bcmath zip pcntl exif curl gd</code></p>"},{"location":"customize/build-settings/#php_extensions_extra","title":"<code>PHP_EXTENSIONS_EXTRA</code>","text":"<p>Named <code>DOCKER_APP_PHP_EXTENSIONS_EXTRA</code> in your <code>.env</code> file</p> <p>Extra PHP Extensions (separated by space) to install via <code>docker-php-ext-install</code>.</p> <p>See the <code>How to install more PHP extensions</code> documentation on Docker Hub for more information.</p> <p>Default value: <code>\"\"</code></p>"},{"location":"customize/build-settings/#php_extensions_database","title":"<code>PHP_EXTENSIONS_DATABASE</code>","text":"<p>PHP database extensions to install.</p> <p>By default, we install both <code>pgsql</code> and <code>mysql</code> since they're more convenient (and add very little build time! But it can be overwritten here if desired.</p> <p>Default value: <code>pdo_pgsql pdo_mysql pdo_sqlite</code></p>"},{"location":"customize/build-settings/#composer_version","title":"<code>COMPOSER_VERSION</code>","text":"<p>The version of Composer to install.</p> <p>For valid values, please see the Docker Hub <code>composer</code> page.</p> <p>Default value: <code>2.6</code></p>"},{"location":"customize/build-settings/#apt_packages_extra","title":"<code>APT_PACKAGES_EXTRA</code>","text":"<p>Named <code>DOCKER_APP_APT_PACKAGES_EXTRA</code> in your <code>.env</code> file</p> <p>Extra APT packages (separated by space) that should be installed inside the image by <code>apt-get install</code></p> <p>Default value: <code>\"\"</code></p>"},{"location":"customize/build-settings/#nginx_version","title":"<code>NGINX_VERSION</code>","text":"<p>The version of <code>nginx</code> to use when targeting <code>nginx-runtime</code>.</p> <p>Please see the Docker Hub <code>nginx</code> page for available versions.</p> <p>Default value: <code>1.25.3</code></p>"},{"location":"customize/build-settings/#forego_version","title":"<code>FOREGO_VERSION</code>","text":"<p>The version of <code>forego</code> to install.</p> <p>Default value: <code>0.17.2</code></p>"},{"location":"customize/build-settings/#gomplate_version","title":"<code>GOMPLATE_VERSION</code>","text":"<p>The version of <code>goplate</code> to install.</p> <p>Default value: <code>v3.11.6</code></p>"},{"location":"customize/build-settings/#dotenv_linter_version","title":"<code>DOTENV_LINTER_VERSION</code>","text":"<p>Version of <code>dotenv-linter</code> to install.</p> <p>Default value: <code>v3.2.0</code></p>"},{"location":"customize/build-settings/#php_base_type","title":"<code>PHP_BASE_TYPE</code>","text":"<p>Named <code>DOCKER_APP_BASE_TYPE</code> in your <code>.env</code> file</p> <p>The <code>PHP</code> base image layer to use when building the runtime container.</p> <p>When targeting</p> <ul> <li><code>apache-runtime</code> use <code>apache</code></li> <li><code>nginx-runtime</code> use <code>fpm</code></li> </ul> <p>Valid values:</p> <ul> <li><code>apache</code></li> <li><code>cli</code></li> </ul> <p>Default value: <code>apache</code></p>"},{"location":"customize/build-settings/#php_debian_release","title":"<code>PHP_DEBIAN_RELEASE</code>","text":"<p>Named <code>DOCKER_APP_DEBIAN_RELEASE</code> in your <code>.env</code> file</p> <p>The <code>Debian</code> Operation System version to use.</p> <p>Valid values:</p> <ul> <li><code>bookworm</code></li> </ul> <p>Default value: <code>bookworm</code></p>"},{"location":"customize/entrypoint/","title":"Entrypoint","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p> <p>Tip</p> <p>Most, if not all, configuration options for both Pixelfed and Docker is included and documented in the <code>.env.docker</code> (or <code>.env</code> file once you copied it during the installation) It's highly recommended to give it a read from top to bottom, or trying to search it for the thing you would like to change.</p> <p>We of course aim for this page to cover everything, and if we missed anything, please submit a Pull Request or a ticket for us </p>"},{"location":"customize/entrypoint/#run-script-on-startup-entrypoint","title":"Run script on startup (ENTRYPOINT)","text":"<p>When a Pixelfed container starts up, the <code>ENTRYPOINT</code> script will</p> <ol> <li>Search the <code>/docker/entrypoint.d/</code> directory for files and for each file (in lexical order).</li> <li>Check if the file is executable.<ol> <li>If the file is not executable, print an error and exit the container.</li> </ol> </li> <li>If the file has the extension <code>.envsh</code>, the file will be sourced.</li> <li>If the file has the extension <code>.sh</code>, the file will be run like a regular script.</li> <li>Any other file extension will log a warning and be ignored.</li> </ol>"},{"location":"customize/entrypoint/#debugging","title":"Debugging","text":"<p>You can set the environment variable <code>DOCKER_APP_ENTRYPOINT_DEBUG=1</code> to show the verbose output of each <code>entrypoint.d</code> script is doing.</p>"},{"location":"customize/entrypoint/#included-scripts","title":"Included scripts","text":"<ul> <li><code>01-permissions.sh</code> (optionally) ensures permissions for files are corrected (see fixing ownership on startup).</li> <li><code>02-check-config.sh</code> Ensures your <code>.env</code> file is valid - like missing quotes or syntax errors.</li> <li><code>04-defaults.envsh</code> calculates Docker container environment variables needed for templating configuration files.</li> <li><code>05-templating.sh</code> renders template configuration files.</li> <li><code>10-storage.sh</code> ensures Pixelfed storage related permissions and commands are run.</li> <li><code>11-first-time-setup.sh</code> automatically runs all \"one time setup\" steps for a new Pixelfed server.</li> <li><code>12-migrations.sh</code> optionally run database migrations on container start up.</li> <li><code>20-horizon.sh</code> ensures Laravel Horizon used by Pixelfed is configured.</li> <li><code>30-cache.sh</code> ensures all Pixelfed caches (router, view, config) are primed.</li> </ul>"},{"location":"customize/entrypoint/#disabling-entrypoint-or-individual-scripts","title":"Disabling <code>ENTRYPOINT</code> or individual scripts","text":"<p>To disable the entire <code>ENTRYPOINT</code> you can set the variable <code>ENTRYPOINT_SKIP=1</code>.</p> <p>To disable individual <code>ENTRYPOINT</code> scripts, you can add the filename to the space (<code>\" \"</code>) separated variable <code>ENTRYPOINT_SKIP_SCRIPTS</code>. (example: <code>ENTRYPOINT_SKIP_SCRIPTS=\"10-storage.sh 30-cache.sh\"</code>)</p>"},{"location":"customize/entrypoint/#override-anything-and-everything","title":"Override anything and everything","text":"<p>Tip</p> <p>With the default Pixelfed <code>docker-compose.yml</code> the <code>overrides</code> bind mount is enabled by default for both <code>web</code> and <code>worker</code> service.</p> <p>The <code>overrides</code> folder on the host machine is in <code>./docker-compose-state/overrides</code> and can be changed via <code>DOCKER_APP_HOST_OVERRIDES_PATH</code> in the <code>.env</code> file.</p> <p>If you mount a bind volume (can be read-only) in <code>/docker/overrides</code> then all files and directories within that directory will be copied on top of <code>/</code>.</p> <p>This enables you to create or override anything within the container during container startup.</p> <p>The copy operation happens as one of the first things in the <code>ENTRYPOINT</code> so you can put even override templates and the included <code>ENTRYPOINT</code> scripts - or add new ones!</p> <p>Of course it can also be used to override <code>php.ini</code>, <code>index.php</code> or any other config/script files you would want to.</p>"},{"location":"customize/entrypoint/#override-examples","title":"Override examples","text":"<ol> <li>To override <code>/usr/local/etc/php/php.ini</code> in the container, put the source file in <code>./docker-compose-state/overrides/usr/local/etc/php/php.ini</code>.</li> <li>To create <code>/a/fantastic/example.txt</code> in the container put the source file in <code>./docker-compose-state/overrides/a/fantastic/example.txt</code>.</li> <li>To override the default <code>/docker/templates/php.ini</code> template, put the source file in <code>./docker-compose-state/overrides/docker/templates/php.ini</code>.</li> <li>To override <code>/a/path/inside/the/container</code>, put the source file in <code>./docker-compose-state/overrides/a/path/inside/the/container</code>.</li> </ol>"},{"location":"customize/entrypoint/#fixing-ownership-on-startup","title":"Fixing ownership on startup","text":"<p>You can set the environment variable <code>DOCKER_APP_ENSURE_OWNERSHIP_PATHS</code> to a list of paths that should have their <code>$USER</code> and <code>$GROUP</code> ownership changed to the configured runtime user and group during container bootstrapping.</p> <p>The variable is a space-delimited list shown below and accepts both relative and absolute paths:</p> <ul> <li><code>DOCKER_APP_ENSURE_OWNERSHIP_PATHS=\"./storage ./bootstrap\"</code></li> <li><code>DOCKER_APP_ENSURE_OWNERSHIP_PATHS=\"/some/other/folder\"</code></li> </ul>"},{"location":"customize/entrypoint/#one-time-setup-tasks","title":"One-time setup tasks","text":"<p>The script stores <code>lock</code> files in the <code>storage/docker/once</code> folder to ensure that these tasks are only run once, so for new Pixelfed servers, you do not need to disable this behavior!</p> <p>The Docker container will by default try to run the required One-time setup tasks for you on startup.</p> <p>If your Pixelfed server already have run these tasks, you must disable this by setting <code>DOCKER_APP_RUN_ONE_TIME_SETUP_TASKS=0</code> in your <code>.env</code> file.</p>"},{"location":"customize/entrypoint/#automatic-database-migrations","title":"Automatic database migrations","text":"<p>The init script will by default only detect if there are new database migrations - but not apply them - as these can potentially be destructive or take a long time to apply.</p> <p>By setting <code>DB_APPLY_NEW_MIGRATIONS_AUTOMATICALLY=1</code> in your <code>.env</code> file, the script will automatically apply new migrations when they are detected.</p>"},{"location":"customize/faq/","title":"FAQ","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p>"},{"location":"customize/faq/#how-do-i-use-my-own-proxy-server","title":"How do I use my own Proxy server?","text":"<p>No problem! All you have to do is:</p> <ol> <li>Change the <code>DOCKER_PROXY_PROFILE</code> key/value pair in your <code>.env</code> file to <code>\"disabled\"</code>.<ul> <li>This disables the <code>proxy</code> and <code>proxy-acme</code> services in <code>docker-compose.yml</code>.</li> <li>The setting is near the bottom of the file.</li> </ul> </li> <li>Point your proxy upstream to the exposed <code>web</code> port (Default: <code>8080</code>).<ul> <li>The port is controlled by the <code>DOCKER_WEB_PORT_EXTERNAL_HTTP</code> key in <code>.env</code>.</li> <li>The setting is near the bottom of the file.</li> </ul> </li> <li>Run <code>docker compose up -d --remove-orphans</code> to apply the configuration</li> </ol>"},{"location":"customize/faq/#how-do-i-use-my-own-ssl-certificate","title":"How do I use my own SSL certificate?","text":"<p>No problem! All you have to do is:</p> <ol> <li>Change the <code>DOCKER_PROXY_ACME_PROFILE</code> key/value pair in your <code>.env</code> file to <code>\"disabled\"</code>.<ul> <li>This disabled the <code>proxy-acme</code> service in <code>docker-compose.yml</code>.</li> <li>It does not disable the <code>proxy</code> service.</li> </ul> </li> <li>Put your certificates in <code>${DOCKER_ALL_HOST_CONFIG_ROOT_PATH}/proxy/certs</code> (e.g. <code>./docker-compose/config/proxy/certs</code>)<ul> <li>You may need to create this folder manually if it does not exist.</li> <li>The following files are expected to exist in the directory for the proxy to detect and use them automatically (this is the same directory and file names as LetsEncrypt uses)<ol> <li><code>${APP_DOMAIN}.cert.pem</code></li> <li><code>${APP_DOMAIN}.chain.pem</code></li> <li><code>${APP_DOMAIN}.fullchain.pem</code></li> <li><code>${APP_DOMAIN}.key.pem</code></li> </ol> </li> <li>See the <code>nginx-proxy</code> configuration file for name patterns</li> </ul> </li> <li>Run <code>docker compose up -d --remove-orphans</code> to apply the configuration</li> </ol>"},{"location":"customize/faq/#how-do-i-change-the-container-name-prefix","title":"How do I change the container name prefix?","text":"<p>Change the <code>DOCKER_ALL_CONTAINER_NAME_PREFIX</code> key/value pair in your <code>.env</code> file.</p>"},{"location":"customize/runtimes/","title":"Container runtimes","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p> <p>The Pixelfed Dockerfile support multiple target runtimes (Apache and Nginx + FPM.</p> <p>You can consider a runtime target as individual Dockerfiles, but instead, all of them are built from the same optimized Dockerfile, sharing +90% of their configuration and packages.</p> <p>What runtime is right for me?</p> <p>If you are unsure of which runtime to choose, please use the Apache runtime; it's the most straightforward one and also the default.</p>"},{"location":"customize/runtimes/#apache","title":"Apache","text":"<p>RECOMMENDED</p> <p>This is the default and recommended runtime for almost all single-server Pixelfed instances, as it has fewer moving parts, simplified operational model, and strikes a good balance between performance, features, and convenience.</p> <p>Building a custom Pixelfed Docker image using <code>Apache</code> + <code>mod_php</code> can be achieved the following way.</p>"},{"location":"customize/runtimes/#docker-build-apache","title":"docker build (Apache)","text":"<pre><code>docker build \\\n -f Dockerfile \\\n --target apache-runtime \\\n --tag &lt;docker hub user&gt;/&lt;docker hub repo&gt; \\\n .\n</code></pre>"},{"location":"customize/runtimes/#docker-compose-apache","title":"docker compose (Apache)","text":"<p>Info</p> <p>This is already configured if you use the default Pixelfed <code>docker-compose.yml</code></p> <p>Instead you control the target runtime via your <code>.env</code> file</p> <pre><code>DOCKER_APP_BASE_TYPE=\"apache\"\nDOCKER_APP_RUNTIME=\"apache\"\n</code></pre> <pre><code>version: \"3\"\n\nservices:\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n      target: apache-runtime\n</code></pre>"},{"location":"customize/runtimes/#nginx-fpm","title":"Nginx + FPM","text":"<p>ADVANCED USAGE</p> <p>Nginx + FPM has more moving parts than the default (and recommended) Apache runtime.</p> <p>Only select this runtime if you have valid technical reasons to do so.</p> <p>Building a custom Pixelfed Docker image using nginx + FPM can be achieved the following way.</p>"},{"location":"customize/runtimes/#docker-build-nginx","title":"docker build (Nginx)","text":"<pre><code>docker build \\\n -f Dockerfile \\\n --target nginx-runtime \\\n --build-arg 'PHP_BASE_TYPE=fpm' \\\n --tag &lt;docker hub user&gt;/&lt;docker hub repo&gt; \\\n .\n</code></pre>"},{"location":"customize/runtimes/#docker-compose-nginx","title":"docker compose (Nginx)","text":"<p>Info</p> <p>This is already configured if you use the default Pixelfed <code>docker-compose.yml</code></p> <p>Instead you control the target runtime via your <code>.env</code> file</p> <pre><code>DOCKER_APP_BASE_TYPE=\"fpm\"\nDOCKER_APP_RUNTIME=\"nginx\"\n</code></pre> <pre><code>version: \"3\"\n\nservices:\n app:\n  build:\n   context: .\n   dockerfile: Dockerfile\n   target: nginx-runtime\n   args:\n     PHP_BASE_TYPE: fpm\n</code></pre>"},{"location":"customize/templating/","title":"Templating","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p> <p>The Docker container can do some basic templating (more like variable replacement) as part of the entrypoint scripts via gomplate.</p> <p>Any file in the <code>/docker/templates/</code> directory will be templated and written to the proper directory.</p>"},{"location":"customize/templating/#file-path-examples","title":"File path examples","text":"<ol> <li>To template <code>/usr/local/etc/php/php.ini</code> in the container, put the source file in <code>/docker/templates/usr/local/etc/php/php.ini</code>.</li> <li>To template <code>/a/fantastic/example.txt</code> in the container put the source file in <code>/docker/templates/a/fantastic/example.txt</code>.</li> <li>To template <code>/some/path/anywhere</code> in the container, put the source file in <code>/docker/templates/some/path/anywhere</code>.</li> </ol>"},{"location":"customize/templating/#available-variables","title":"Available variables","text":"<p>Variables available for templating are sourced (in order, so last source takes precedence) like this:</p> <ol> <li><code>env:</code> in your <code>docker-compose.yml</code> or <code>-e</code> in your <code>docker run</code> / <code>docker compose run</code> commands.</li> <li>Any exported variables in <code>.envsh</code> files loaded before <code>05-templating.sh</code> (e.g., any file with <code>04-</code>, <code>03-</code>, <code>02-</code>, <code>01-</code> or <code>00-</code> prefix).</li> <li>All key and value pairs in <code>/var/www/.env.docker</code> (default values, you should not edit this file!)</li> <li>All key and value pairs in <code>/var/www/.env</code>.</li> </ol>"},{"location":"customize/templating/#template-guide-101","title":"Template guide 101","text":"<p>Please see the <code>gomplate</code> documentation for a comprehensive overview.</p> <p>The most frequent use case you have is likely to print an environment variable (or a default value if it's missing), so this is how to do that:</p> <ul> <li><code>{{ getenv \"VAR_NAME\" }}</code> print an environment variable and fail if the variable is not set. (docs)</li> <li><code>{{ getenv \"VAR_NAME\" \"default\" }}</code> print an environment variable and print <code>default</code> if the variable is not set. (docs)</li> </ul> <p>The script will fail if you reference a variable that does not exist (and doesn't have a default value) in a template.</p> <p>Please see the</p> <ul> <li><code>gomplate</code> syntax documentation</li> <li><code>gomplate</code> functions documentation</li> </ul>"},{"location":"installation/","title":"Guide","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p> <p>Connect via SSH to your server and decide where you want to install Pixelfed.</p> <p>Info</p> <p>In this guide, I will assume you will install Pixelfed in <code>/data/pixelfed</code> and that the Docker Prerequisites are met.</p> <p>You can change the installation path; update the commands below to fit your setup.</p>"},{"location":"installation/#initial-set-up","title":"Initial set up","text":""},{"location":"installation/#create-the-directory","title":"Create the directory","text":"<pre><code>mkdir -p /data\n</code></pre>"},{"location":"installation/#clone-the-pixelfed-project","title":"Clone the Pixelfed project","text":"<pre><code>git clone \\\n    --branch jippi-fork \\\n    https://github.com/jippi/pixelfed.git \\\n    /data/pixelfed\n</code></pre>"},{"location":"installation/#change-directory","title":"Change directory","text":"<pre><code>cd /data/pixelfed\n</code></pre>"},{"location":"installation/#configuring-your-site","title":"Configuring your site","text":""},{"location":"installation/#copy-the-example-file","title":"Copy the example file","text":"<p>Pixelfed contains a default configuration file (<code>.env.docker</code>) you should use as a starter; however, before editing anything, make a copy of it and put it in the right place (<code>.env</code>).</p> <p>Run the following command to copy the file:</p> <pre><code>cp .env.docker .env\n</code></pre>"},{"location":"installation/#modify-config-file","title":"Modify config file","text":"<p>The configuration file is quite long, but the good news is that you can ignore most of it; most of the server-specific settings are configured for you out of the box.</p> <p>The minimum required settings you must change is:</p> <ul> <li>(required) <code>APP_DOMAIN</code>, which is the hostname you plan to run your Pixelfed server on (e.g., <code>pixelfed.social</code>) - must not include <code>http://</code> or a trailing slash (<code>/</code>)!</li> <li>(required) <code>DB_PASSWORD</code>, which is the database password; you can use a service like pwgen.io to generate a secure one.</li> <li>(optional) <code>ENFORCE_EMAIL_VERIFICATION</code> should be set to <code>\"false\"</code> if you don't plan to send e-mails.</li> <li>(optional) <code>MAIL_DRIVER</code> and related <code>MAIL_*</code> settings if you plan to use an E-mail/SMTP provider - See E-mail variables documentation.</li> <li>(optional) <code>PF_ENABLE_CLOUD</code> / <code>FILESYSTEM_CLOUD</code> if you plan to use an Object Storage provider.</li> </ul> <p>See the <code>Configure environment variables</code> documentation for details!</p> <p>You need to mainly focus on the following sections.</p> <ul> <li>App variables</li> <li>Email variables</li> </ul> <p>You can skip the following sections since they are already configured/automated for you:</p> <ul> <li><code>Redis</code></li> <li><code>Database</code> (except for <code>DB_PASSWORD</code>)</li> <li><code>One-time setup tasks</code></li> </ul>"},{"location":"installation/#starting-the-service","title":"Starting the service","text":"<p>With everything in place and (hopefully) well-configured, we can now go ahead and start our services by running:</p> <pre><code>docker compose up -d\n</code></pre> <p>This will download all the required Docker images, start the containers, and begin the automatic setup.</p> <p>You can follow the logs by running <code>docker compose logs</code> - you might want to scroll to the top to logs from the start.</p> <p>You can use the CLI flag <code>--tail=100</code> to only see each container's most recent (<code>100</code> in this example) log lines.</p> <p>You can use the CLI flag <code>--follow</code> to continue to see log output from the containers.</p> <p>You can combine <code>--tail=100</code> and <code>--follow</code> like this <code>docker compose logs --tail=100 --follow</code>.</p> <p>If you only care about specific containers, you can add them to the end of the command like this <code>docker-compose logs web worker proxy.</code></p>"},{"location":"installation/#done","title":"Done","text":"<p>You made it to the end of the installation tutorial and hopefully you have fully functional Pixelfed instance.</p> <p>We recommend your next steps is to check out how to customize your Pixelfed instance</p> <p>If anything was confusing, unclear, or maybe even wrong on this page, then please let us know by submitting a bug report </p>"},{"location":"installation/prerequisites/","title":"Prerequisites","text":"<p>If anything is confusing, unclear, missing, or maybe even wrong on this page, then please let us know by submitting a bug report </p> <p>This guide will help you install and run Pixelfed on your server using Docker Compose.</p> <p>Recommendations and requirements for hardware and software needed to run Pixelfed using Docker Compose.</p> <p>You should have some experience with Linux (e.g., Ubuntu or Debian), SSH, and lightweight server administration.</p>"},{"location":"installation/prerequisites/#server","title":"Server","text":"<p>A Virtual Private Server (VPS) or Dedicated Server (also known as <code>root server</code>) you can SSH into, for example:</p> <ul> <li>linode.com VPS</li> <li>DigitalOcean VPS</li> <li>Hetzner</li> </ul>"},{"location":"installation/prerequisites/#hardware","title":"Hardware","text":"<p>Hardware requirements depend on the number of users you have (or plan to have) and how active they are.</p> <p>A safe starter/small instance hardware for ~25 users and below are:</p> <ul> <li>CPU/vCPU <code>2</code> cores.</li> <li>RAM <code>2-4 GB</code> As your instance grows, memory requirements will increase for the database.</li> <li>Storage <code>20-50 GB</code> HDD is fine, but ideally, SSD or NVMe, especially for the database.</li> <li>Network <code>100 Mbit/s</code> or faster.</li> </ul>"},{"location":"installation/prerequisites/#software","title":"Software","text":"<p>Required software to be installed on your server</p> <ul> <li><code>git</code> can be installed with <code>apt-get install git</code> on Debian/Ubuntu</li> <li><code>docker</code> can be installed by following the official Docker documentation</li> </ul>"},{"location":"installation/prerequisites/#network","title":"Network","text":"<ul> <li>Port <code>80</code> (HTTP) and <code>443</code> (HTTPS) ports forwarded to the server.</li> <li>Example for Ubuntu using <code>ufw</code> for port <code>80</code>: <code>ufw allow 80</code></li> <li>Example for Ubuntu using <code>ufw</code> for port <code>443</code>: <code>ufw allow 443</code></li> </ul>"},{"location":"installation/prerequisites/#domain-and-dns","title":"Domain and DNS","text":"<ul> <li>A Domain (or subdomain) is needed for the Pixelfed server (for example, <code>pixelfed.social</code> or <code>pixelfed.mydomain.com</code>)</li> <li>Having the required <code>A</code>/<code>CNAME</code> DNS records for your domain (above) pointing to your server.</li> <li>Typically, an <code>A</code> record for the root (sometimes shown as <code>@</code>) record for <code>mydomain.com</code></li> <li>Possibly an <code>A</code> record for <code>www.</code> subdomain.</li> </ul>"},{"location":"installation/prerequisites/#smtp-provider-optional","title":"SMTP provider (Optional)","text":"<p>What is this?</p> <p>An E-mail/SMTP provider is used for sending e-mails to your users, such as e-mail confirmation and notifications.</p> <p>If you don't plan to use an e-mail/SMTP provider, then make sure to set <code>ENFORCE_EMAIL_VERIFICATION=\"false\"</code> in your <code>.env</code> file!</p> <p>There are many providers out there with wildly different pricing structures, features, and reliability.</p> <p>It's beyond the scope of this document to detail which provider to pick or how to correctly configure them. Still, some providers that are known to be working well - with generous free tiers and affordable packages - are included for your convince (in no particular order) below:</p> <ul> <li>Simple Email Service (SES) by Amazon Web Services (AWS) is pay-as-you-go with a cost of $0.10/1000 emails.</li> <li>Brevo (formerly SendInBlue) has a Free Tier with 300 e-mails/day.</li> <li>Postmark has a Free Tier with 100 e-mails/month.</li> <li>Forward Email has a $3/mo/domain plan with both sending and receiving included.</li> <li>Mailtrap has a 1000 e-mails/month free tier (their <code>E-mail Sending</code> product, not the <code>E-mail Testing</code> one).</li> </ul>"},{"location":"installation/prerequisites/#object-storage-optional","title":"Object Storage (Optional)","text":"<p>What is this?</p> <p>An Object Storage provider stores all media content remotely rather than locally on your server. It's often cheaper to use an Object Storage service than to have media files stored directly on the HDD, especially for medium to large data volumes.</p> <p>This is entirely optional - by default, Pixelfed will store all uploads (videos, images, etc.) directly on your servers' storage.</p> <p>Object storage is a technology that stores and manages data in an unstructured format called objects. Modern organizations create and analyze large volumes of unstructured data such as photos, videos, e-mail, web pages, sensor data, and audio files.</p> <p>-- What is object storage? by Amazon Web Services</p> <p>It's beyond the scope of this document to detail which provider to pick or how to correctly configure them. Still, some providers that are known to be working well - with generous free tiers and affordable packages - are included for your convince (in no particular order) below:</p> <ul> <li>R2 by Cloudflare has cheap storage, free egress (e.g., people downloading images), and included (and free) Content Delivery Network (CDN).</li> <li>B2 cloud storage by Backblaze.</li> <li>Simple Storage Service (S3) by Amazon Web Services.</li> </ul>"},{"location":"migrate/v2.0/","title":"v2 (pixelfed/pixelfed)","text":"<p>This document assuming you want to upgrade the upstream Docker Compose v2 setup!</p> <p>There are a lot of changes in how Pixelfed Docker/Docker Compose images work - it's a complete rewrite - with a couple of breaking/significant changes.</p> <p>But don't worry! This document and the Migration Guide further down covers all of the required changes and steps you need to safely migrate.</p> <p>We don't take breaking changes or lengthy migration guides lightly, and future iterations and improvements will be either seamless or much smaller in scope and complexity.</p> <p>We do however believe that the many improvements (listed below) are worth it, and sets us up for a brighter future for self-hosted and maintainable Pixelfed servers</p>"},{"location":"migrate/v2.0/#breaking-changes","title":"Breaking Changes","text":"<p>These changes are breaking, removing, or changing existing behavior from Docker Compose v1 and requires your attention and possibly some steps to fix. The Migration Guide has step by step guide for most of these!</p>"},{"location":"migrate/v2.0/#breaking-change-new-dockerfile","title":"Breaking Change New <code>Dockerfile</code>","text":"<p>All runtime variations of Pixelfed on Docker are now build from a single <code>Dockerfile</code>, rather than the previously three.</p> <p>Please see the Docker Runtimes and Docker Customization documentation for more information.</p>"},{"location":"migrate/v2.0/#breaking-change-new-docker-compose-file","title":"Breaking Change New Docker Compose file","text":"<p>The <code>docker-compose.yml</code> file has been rewritten from the ground up to be provide better defaults and more flexible out of the box.</p> <p>This mean that most things you would likely want to tweak can be controlled from your <code>.env</code> config file, like installing additional APT Packages, PECL/PHP extensions, changing PHP version, modifying PHP settings (such as <code>memory_limit</code>), disabling specific services, changing where data and config files are stored, and so on.</p>"},{"location":"migrate/v2.0/#breaking-change-new-env-envdocker-file","title":"Breaking Change New <code>.env</code> / <code>.env.docker</code> file","text":"<p>The starter <code>.env.docker</code> file has been significantly expanded with most of the Pixelfed settings available, along with many Docker Compose specific ones.</p> <p>Your Pixelfed specific settings are (of course) unchanged, but you need to configure them again after copying the new <code>.env.docker</code> file.</p>"},{"location":"migrate/v2.0/#breaking-change-using-bind-volumes","title":"Breaking Change Using <code>bind</code> volumes","text":"<p>The old <code>docker-compose.yml</code> configuration file declared four anonymous Docker volumes for storing Pixelfed related data within.</p> <p>These are no longer used, instead favoring a Docker bind volume approach where content is stored directly on the server disk, outside of a Docker volume.</p> <p>The consequence of this change is that all data stored in the - now unsupported - Docker volumes will no longer be accessible by Pixelfed.</p> <ul> <li>The <code>db-data</code> volume definitely contains important data - it's your database, after all!</li> <li>The <code>app-storage</code> volume definitely contains important data - it's files uploaded to - or seen by - your server!</li> <li>The <code>redis-data</code> volume might contain important data (depending on your configuration)</li> <li>The <code>app-bootstrap</code> volume does not contain any important data - all of it will be generated automatically in the new setup on startup. We will not be migrating this!</li> </ul> <p>Please see the Migration steps section for information on moving your data.</p>"},{"location":"migrate/v2.0/#breaking-change-no-docker-networks","title":"Breaking Change No Docker networks","text":"<p>The <code>docker-compose.yml</code> no longer include any custom networks, instead favoring the simplicity of the default <code>bridge</code> network.</p> <p>The published ports can be configured via your <code>.env</code> file, look for the <code>DOCKER_*_HOST_PORT</code> keys.</p>"},{"location":"migrate/v2.0/#changes-needing-attention","title":"Changes needing attention","text":"<p>These changes are mostly informational and unlikely to cause any issues during upgrade, but included for visibility and in case your specific set up require them to be changed.</p>"},{"location":"migrate/v2.0/#requires-attention-new-redis-version","title":"Requires Attention New Redis version","text":"<p>Redis has been upgraded from using the last version <code>5</code> release to using the latest <code>7.2</code> version instead - favoring the <code>debian</code> variant instead of <code>alpine</code>.</p> <p>The Redis version can be controlled in your <code>.env</code> file via <code>DOCKER_REDIS_VERSION</code>.</p> <p>If you want to keep using the Redis version set <code>DOCKER_REDIS_VERSION=\"5-alpine\"</code> in your <code>.env</code> file.</p> <p>If you want to use <code>7.2</code> but the alpine variant, simply append <code>-alpine</code> to the <code>DOCKER_REDIS_VERSION</code> (e.g. <code>DOCKER_REDIS_VERSION=7.2-alpine</code>).</p>"},{"location":"migrate/v2.0/#requires-attention-pinned-mariadb-version","title":"Requires Attention Pinned MariaDB version","text":"<p>The included <code>db</code> service is now pinned to MariaDB <code>11.2</code> instead of <code>latest</code>.</p> <p>You can revert to the previous setting by setting <code>DB_VERSION=\"latest\"</code> in your <code>.env</code> file.</p>"},{"location":"migrate/v2.0/#requires-attention-automatic-one-time-setup-tasks","title":"Requires Attention Automatic \"One-time setup tasks\"","text":"<p>This is also covered in the migration guide but existing Pixelfed instances need to disable the automatic run of One-time setup tasks by setting <code>DOCKER_APP_RUN_ONE_TIME_SETUP_TASKS=0</code> in your <code>.env</code> file.</p> <p>Your container will fail to start up if these are already configured for your site.</p>"},{"location":"migrate/v2.0/#new-or-improved-features","title":"New or improved features","text":"<p>All the new and exciting features and capabilities. </p> <p>This is where we hope we can convince you that the breaking changes and migration work was worth it </p>"},{"location":"migrate/v2.0/#improvement-nginx-proxy-service","title":"Improvement Nginx Proxy service","text":"<p>The new <code>docker-compose.yml</code> includes an optional (but enabled by default) Nginx Proxy for SSL/TLS termination.</p> <p>Please see <code>How do I use my own Proxy server?</code> and <code>DOCKER_PROXY_*</code> keys in the <code>.env</code> file for more information.</p>"},{"location":"migrate/v2.0/#improvement-letsencryptacme-service","title":"Improvement LetsEncrypt/ACME service","text":"<p>The new <code>docker-compose.yml</code> includes an optional (but enabled by default) ACME/LetsEncrypt service that when combined with the new Nginx Proxy automatically creates and maintains your SSL/TLS certificates.</p> <p>Please see <code>How do I use my own SSL certificate?</code> and <code>DOCKER_PROXY_*</code> + <code>LETSENCRYPT_*</code> keys in the <code>.env</code> file for more information.</p>"},{"location":"migrate/v2.0/#improvement-automatic-run-of-one-time-setup-tasks","title":"Improvement Automatic run of \"One-time setup tasks\"","text":"<p>When you set up a new Pixelfed server, there is handful of commands you need to run once (and only once) - these are called One-time setup tasks.</p> <p>These steps are now automatically run for you when creating a new Pixelfed server.</p>"},{"location":"migrate/v2.0/#improvement-extensive-documentation","title":"Improvement Extensive documentation","text":"<p>How to run and use the new Docker setup has been documented extensively. Not only on this page, but also in all the new scripts, <code>Dockerfile</code>, and <code>.env.docker</code> file.</p> <p>We hope this will make it much easier to confidently and comfortably run your Pixelfed server with Docker - and when things do go wrong, the debugging and fixing of the issue much easier and quicker.</p>"},{"location":"migrate/v2.0/#improvement-automatic-publishing-of-docker-images","title":"Improvement Automatic publishing of Docker images","text":"<p>Going forward we will automatically build and push Docker images for Pixelfed to both Docker Hub and GitHub Container Registry.</p> <p>We will automatically be pushing all combinations of our supported Docker runtimes and PHP version (8.1, 8.2 and soon 8.3).</p> <p>Further more, testing Pull Requests has never been easier, as we will also build and push Docker images for all Pull Requests with tag prefix <code>pr-{ID}</code> (e.x. <code>pixelfed/pixelfed:pr-4844-apache-8.2</code>).</p> <p>You can control which Pixelfed release you use via the <code>DOCKER_APP_RELEASE</code> key/value pair in your <code>.env</code> file.</p>"},{"location":"migrate/v2.0/#improvement-customizable-dockerfile","title":"Improvement Customizable <code>Dockerfile</code>","text":"<p>It's now possible to tweak many Docker related settings without copying or forking Pixelfed Dockerfile!</p> <p>The new Dockerfile has many Build Arguments (e.g., <code>--build-arg</code>) allowing you to easily</p> <ul> <li>Change your PHP version</li> <li>Install extra PECL extensions</li> <li>Install extra PHP extensions</li> <li>Install extra APT packages</li> <li>Change Debian version</li> </ul> <p>All of these (and more) settings are controlled from your <code>.env</code> file, and you simply need to run <code>docker compose build</code> to build your own bespoke version of Pixelfed on your server!</p>"},{"location":"migrate/v2.0/#improvement-customizable-entrypoint","title":"Improvement Customizable <code>ENTRYPOINT</code>","text":"<p>Do you want to run a script on container start up? Or perhaps to disable a specific init script? Or even disable all of the init scripts?</p> <p>Now you can! And like with all the other settings it's just a setting in your <code>.env</code> file!</p>"},{"location":"migrate/v2.0/#improvement-templating-files","title":"Improvement Templating files","text":"<p>The new <code>ENTRYPOINT</code> system offers an extensible and flexible way for you to template configuration files such as your <code>php.ini</code> during container start up.</p> <p>The templating system has access to all settings from your <code>.env</code> file, and you can easily add your own templates!</p>"},{"location":"migrate/v2.0/#improvement-automatic-phpweb-server-configuration","title":"Improvement Automatic PHP/Web server configuration","text":"<p>Thanks to the new templating system we now automatically calculate and configure required PHP / Web server settings for you - using your <code>.env</code> settings - such as</p> <ul> <li>(php.ini) <code>upload_max_filesize</code> with this formula <code>(MAX_PHOTO_SIZE * MAX_ALBUM_LENGTH) + BUFFER</code></li> <li>(php.ini) <code>post_max_size</code> with this formula <code>(MAX_PHOTO_SIZE * MAX_ALBUM_LENGTH) + BUFFER</code></li> <li>(php.ini) <code>max_file_uploads</code> using <code>MAX_ALBUM_LENGTH</code></li> <li>(php.ini) <code>memory_limit</code> using <code>PHP_MEMORY_LIMIT</code></li> <li>(php.ini) <code>[Date]date.timezone</code> using <code>APP_TIMEZONE</code></li> </ul>"},{"location":"migrate/v2.0/#improvement-permission-auto-fixing","title":"Improvement Permission auto-fixing","text":"<p>If your installation for some reason has issues with permissions to files/directories, you can now automatically fix ownership and permissions on start up.</p> <p>This is an opt-in feature.</p>"},{"location":"migrate/v2.0/#improvement-faster-docker-image-building","title":"Improvement Faster Docker image building","text":"<p>We now utilize BuildKit, layer caching, multi-stage, and multi-platform to really speed up the building of Docker images.</p> <p>Under ideal conditions, a <code>docker compose build</code> can now complete in less than a minute for most PHP changes. This of course also improve the speed of building Docker images in GitHub Actions and CI!</p>"},{"location":"migrate/v2.0/#improvement-fork-friendly-docker-releasing","title":"Improvement Fork friendly Docker releasing","text":"<p>Forks of Pixelfed that have enabled GitHub Actions should automatically have the same Docker build + push experience as pixelfed/pixelfed have.</p> <p>The <code>docker</code> workflow will by default build + push to the GitHub Container Registry for the project the commit was made to, meaning any downstream projects will not have to fork or modify their <code>docker</code> workflow to have a reliable release proccess.</p> <p>Forks can further more set GitHub Actions Project variables <code>DOCKER_HUB_USERNAME</code>, <code>DOCKER_HUB_ORGANISATION</code>, <code>DOCKER_HUB_REPO</code> and <code>DOCKER_HUB_TOKEN</code> for automatic pushing of images to Docker Hub as well. Please see the <code>.github/workflows/docker.yml</code> file for more information.</p>"},{"location":"migrate/v2.0/#migration-steps","title":"Migration steps","text":"<p>This is a best-effort guide to help migrate off the old system. The operation is potentially complicated (and risky), so please be careful!</p> <p>Danger</p> <p>PLEASE MAKE SURE TO BACKUP YOUR SERVER AND DATA BEFORE ATTEMPTING A MIGRATION</p> <p>YOUR INSTANCE WILL BE DOWN WHILE DOING THE MIGRATION; PLEASE PLAN ACCORDINGLY; DEPENDING ON DATA SIZE IT COULD TAKE ANYWHERE FROM 5 MINUTES TO 5 HOURS</p>"},{"location":"migrate/v2.0/#1-backup","title":"1) Backup","text":"<ol> <li>Make sure to back up your server (ideally after step 1 below has been completed, but before is better than not at all!)</li> <li>Capture the current Git version / Pixelfed release you are on (e.g., <code>git --no-pager log -1</code> outputs the commit reference as the 2<sup>nd</sup> word in the first line)</li> <li>Backup your <code>.env</code> file (we will do this in step 3 as well)</li> <li>Backup your <code>docker-compose.yml</code> file (<code>cp docker-compose.yml docker-compose.yml.old</code>)</li> <li>Read through the entire document before starting</li> </ol>"},{"location":"migrate/v2.0/#2-migrate-env-file","title":"2) Migrate <code>.env</code> file","text":"<p>The new <code>.env</code> file for Docker is a bit different from the old one (many new settings!) so the easiest is to grab the new <code>.env.docker</code> file and modify it from scratch again.</p> <pre><code>cp .env .env.old\nwget -O .env.new https://raw.githubusercontent.com/jippi/pixelfed/jippi-fork/.env.docker\n</code></pre> <p>Then open your old <code>.env.old</code> configuration file, and for each of the key/value pairs within it, find and update the key in the new <code>.env.new</code> configuration file.</p> <p>Don't worry, though; the file might look different (and significantly larger), but it behaves exactly the way the old file did; it just has way more options!</p> <p>!!!! tip \"Don't worry if a key is missing in <code>.env.new</code>; you can add those key/value pairs back to the new file - ideally in the <code>Other configuration</code> section near the end of the file - but anywhere should be fine.\"</p> <p>This is a great time to review your settings and familiarize yourself with all the new ones.</p> <p>Info</p> <p>In particular the following sections</p> <ul> <li><code>PHP configuration</code> section (near the end of the file) where</li> <li>The <code>DOCKER_APP_PHP_VERSION</code> settings control your PHP version</li> <li>The <code>PHP_MEMORY_LIMIT</code> settings control your PHP memory limit</li> <li><code>Docker Specific configuration</code> section (near the end of the file) where</li> <li>The <code>DOCKER_ALL_HOST_DATA_ROOT_PATH</code> setting dictates where the newly migrated data will live.</li> <li>The <code>DOCKER_APP_RUN_ONE_TIME_SETUP_TASKS</code> controls whether the <code>One-time setup tasks</code> should run. We do not want this since your Pixelfed instance is already set up!</li> <li>Frequently Asked Question / FAQ</li> <li>How do I use my own Proxy server?</li> <li>How do I use my own SSL certificate?</li> </ul>"},{"location":"migrate/v2.0/#3-stop-containers","title":"3) Stop containers","text":"<p>This will take your Pixelfed instance offline</p> <p>Stop all running containers (web, worker, redis, db)</p> <pre><code>docker compose down\n</code></pre>"},{"location":"migrate/v2.0/#4-update-source-code","title":"4) Update source code","text":"<p>Update your project to the latest release of Pixelfed by running:</p> <pre><code>git pull origin $release\n</code></pre> <p>The <code>$release</code> can be any valid git reference like <code>dev,</code> <code>staging</code>, or a tagged release such as <code>v0.12.0</code>.</p>"},{"location":"migrate/v2.0/#5-migrate-data","title":"5) Migrate data","text":"<p>The migration guide temporarily branches into two paths here:</p> <ul> <li>Path A if you used Docker Anonymous Volumes.</li> <li>Path B if you used host/bind volumes.</li> </ul> <p>Which Docker volume type am I using?</p> <p>If your old <code>docker-compose.yml</code> had a <code>volumes</code> configuration section like below, you used should follow Path A.</p> <p>This is also what the v1 <code>docker-compose.yml</code> file for pixelfed/pixelfed used.</p> <pre><code>volumes:\ndb-data:\nredis-data:\napp-storage:\napp-bootstrap:\n</code></pre>"},{"location":"migrate/v2.0/#a-anonymous-volumes","title":"A) Anonymous volumes","text":"<p>Warning</p> <p>It's important to note that this is a copy operation - so disk usage will (temporarily) double while you migrate</p> <p>We provide a \"migration container\" for your convenience that can access both the new and old volumes, allowing you to copy the data into the setup.</p> <p>You can use <code>mv</code> (move files) instead of <code>rsync</code> in the guide below - but this is a be a destructive action, so you can't quickly roll back to your old setup, as the data no longer exists in the anonymous Docker volumes.</p>"},{"location":"migrate/v2.0/#a1-run-migration-container","title":"A1) Run migration container","text":"<p>You can access the Docker container with both old and new volumes by running the following command:</p> <pre><code>docker compose -f docker-compose.migrate.yml run migrate bash\n</code></pre> <p>This will put you in the <code>/migrate</code> directory within the container, containing 9 directories like shown here:</p> <pre><code>|-- app-storage\n|   |-- new\n|   `-- old\n|-- db-data\n|   |-- new\n|   `-- old\n`-- redis-data\n    |-- new\n    `-- old\n</code></pre>"},{"location":"migrate/v2.0/#a2-check-old-folders","title":"A2) Check old folders","text":"<p>First thing we want to do is to check if the data inside the container looks correct!</p> <p>The following commands should all return SOME files and data - if they do not - then there might be an issue with the anonymous volume binding.</p> <p>The content of the old folders may not be exactly whats show in the examples below - if a couple of the files or folders match, it's extremely likely it's correct!</p> <pre><code>$ ls app-storage/old\napp  debugbar  docker  framework  logs\noauth-private.key  oauth-public.key  purify\n\n# Redis data might also be entirely empty, thats *okay*\n$ ls redis-data/old\nappendonlydir server.pid\n\n$ ls db-data/old\naria_log_control  ddl_recovery-backup.log  ib_buffer_pool  ib_logfile0\nibdata1  mariadb_upgrade_info  multi-master.info  mysql\nperformance_schema  pixelfed_prod  sys  undo001  undo002  undo003\n</code></pre>"},{"location":"migrate/v2.0/#a3-check-new-folders","title":"A3) Check new folders","text":"<p>The following commands should all return NO files and data - if they contain data - you need to delete it (backup first!) or skip that migration step.</p> <p>If you haven't run <code>docker compose up</code> since you updated your project in step (2) - they should be empty and good to go.</p> <pre><code>ls app-storage/new\nls db-data/new\nls redis-data/new\n</code></pre>"},{"location":"migrate/v2.0/#a4-copy-data","title":"A4) Copy data","text":"<p>This is where we potentially will double your disk usage (temporarily)</p> <p>Now we will copy the data from the old volumes to the new ones.</p> <p>The migration container has <code>rsync</code> installed - which is perfect for that kind of work!</p> <p>NOTE It's important that the \"source\" (first path in the <code>rsync</code> command) has a trailing <code>/</code> - otherwise, the directory layout will turn out wrong!</p> <p>NOTE Depending on your server, these commands might take some time to finish; each command should provide a progress bar with a rough time estimation.</p> <p>NOTE <code>rsync</code> should preserve ownership, permissions, and symlinks correctly for you and all the files copied.</p> <p>Let's copy the data by running the following commands:</p> <pre><code>rsync -avP app-storage/old/ app-storage/new\nrsync -avP db-data/old/ db-data/new\nrsync -avP redis-data/old/ redis-data/new\n</code></pre>"},{"location":"migrate/v2.0/#a5-sanity-checking","title":"A5) Sanity checking","text":"<p>Let's make sure everything is copied over successfully!</p> <p>Each new directory should contain something like (but not always exactly) the following - NO directory should have a single folder called <code>old</code>; if they do, the <code>rsync</code> commands above didn't work correctly - and you need to move the content of the <code>old</code> folder into the \"root\" of the <code>new</code> folder like shown a bit in the following sections.</p> <p>The redis-data/new directory might also contain a <code>server.pid</code></p> <pre><code>$ ls redis-data/new\nappendonlydir\n</code></pre> <p>The app-storage/new directory should look something like this</p> <pre><code>$ ls app-storage/new\napp  debugbar  docker  framework  logs  oauth-private.key  oauth-public.key  purify\n</code></pre> <p>The db-data/new directory should look something like this. There might be a lot of files or very few files, but there must be a <code>mysql</code>, <code>performance_schema</code>, and <code>${DB_DATABASE}</code> (e.g., <code>pixelfed_prod</code> directory)</p> <pre><code>$ ls db-data/new\naria_log_control  ddl_recovery-backup.log  ib_buffer_pool  ib_logfile0  ibdata1  mariadb_upgrade_info  multi-master.info  mysql  performance_schema  pixelfed_prod  sys  undo001  undo002  undo003\n</code></pre> <p>If everything looks good, type <code>exit</code> to leave the migration container.</p>"},{"location":"migrate/v2.0/#b-bindhost-volumes","title":"B) Bind/Host volumes","text":"<p>If you used Bind/Host volumes, then this guide can't offer any hard step-by-step guide to move your data, but instead will let you know how things would look if you started from scratch, so you can mirror or change this behavior.</p> <p>In your <code>.env</code> file, the following KEY/VALUE pairs controls where your data and config files will go - please review each and make sure your files are in these paths, or adjust them to fit your current layout.</p> <p>You can see in the <code>docker-compose.yml</code> file for each <code>service volume</code> section how they are used.</p> <ul> <li><code>DOCKER_ALL_HOST_DATA_ROOT_PATH</code> - The \"root\" path for all service data.</li> </ul> <p>Default: <code>./docker-compose-state/data</code></p> <ul> <li><code>DOCKER_ALL_HOST_CONFIG_ROOT_PATH</code> - The \"root\" path for all service configs.</li> </ul> <p>Default: <code>./docker-compose-state/config</code></p> <ul> <li><code>DOCKER_APP_HOST_STORAGE_PATH</code> (<code>/var/www/storage</code>) - Path for Pixelfed <code>storage</code>, e.x., uploads by users, emojis, and such</li> </ul> <p>Default: <code>${DOCKER_ALL_HOST_DATA_ROOT_PATH}/pixelfed/storage</code></p> <ul> <li><code>DOCKER_APP_HOST_CACHE_PATH</code> (<code>/var/www/bootstrap/cache</code>)</li> </ul> <p>Path for Pixelfed <code>bootstrap/cache</code> data.</p> <p>Default: <code>${DOCKER_ALL_HOST_DATA_ROOT_PATH}/pixelfed/cache</code></p> <ul> <li><code>DOCKER_REDIS_HOST_DATA_PATH</code></li> </ul> <p>Path where <code>Redis</code> will store it's data.</p> <p>Default: <code>${DOCKER_ALL_HOST_DATA_ROOT_PATH}/redis</code></p> <ul> <li><code>DOCKER_DB_HOST_DATA_PATH</code></li> </ul> <p>Path where your database (<code>MariaDB</code>) store it's data.</p> <p>Default: <code>${DOCKER_ALL_HOST_DATA_ROOT_PATH}/db</code></p>"},{"location":"migrate/v2.0/#6-start-containers","title":"6) Start containers","text":"<p>With all an updated Pixelfed (step 2), updated <code>.env</code> file (step 3), and migrated data (steps 4, 5, 6, and 7), we're ready to start things back up again.</p> <p>But before we start your Pixelfed server, let's put the new <code>.env</code> file we made in step 1 in its proper place.</p> <pre><code>cp .env.new .env\n</code></pre>"},{"location":"migrate/v2.0/#the-database","title":"The Database","text":"<p>The first thing we want to try is to start up the database by running the following command and checking the logs:</p> <pre><code>docker compose up -d db\ndocker compose logs --tail 250 --follow db\n</code></pre> <p>If there are no errors and the server isn't crashing, great! If you have an easy way of connecting to the database via a GUI or CLI client, do that as well and verify the database and tables are all there.</p>"},{"location":"migrate/v2.0/#redis","title":"Redis","text":"<p>The next thing we want to try is to start up the Redis server by running the following command and checking the logs:</p> <pre><code>docker compose up -d redis\ndocker compose logs --tail 250 --follow redis\n</code></pre> <p>if there are no errors and the server isn't crashing, great!</p>"},{"location":"migrate/v2.0/#worker","title":"Worker","text":"<p>The next thing we want to try is to start up the Worker server by running the following command and checking the logs:</p> <pre><code>docker compose up -d worker\ndocker compose logs --tail 250 --follow worker\n</code></pre> <p>The container should output a lot of logs from the docker-entrypoint system, but eventually you should see these messages</p> <ul> <li><code>Configuration complete; ready for start up</code></li> <li><code>Horizon started successfully.</code></li> </ul> <p>If you see one or both of those messages, the worker seems to be running.</p> <p>If the worker is crash looping, inspect the logs and try to resolve the issues.</p> <p>You can consider the following additional steps:</p> <ul> <li>Enabling <code>DOCKER_APP_ENTRYPOINT_DEBUG</code>, which will show even more log output to help understand what is going on</li> <li>Enabling <code>DOCKER_APP_ENSURE_OWNERSHIP_PATHS</code> against the path(s) that might have permission issues</li> <li>Fixing permission issues directly on the host since your data should all be in the <code>${DOCKER_ALL_HOST_DATA_ROOT_PATH}</code> folder (<code>./docker-compose-state/data</code> by default)</li> </ul>"},{"location":"migrate/v2.0/#web","title":"Web","text":"<p>The final service, <code>web,</code> will bring your site back online! What a journey it has been.</p> <p>Let's get to it: run these commands to start the <code>web</code> service and inspect the logs.</p> <pre><code>docker compose up -d web\ndocker compose logs --tail 250 --follow web\n</code></pre> <p>The output should be identical to that of the <code>worker</code>, so please see that section for debugging tips if the container is crash looping.</p> <p>If the <code>web</code> service comes online without issues, start the rest of the (optional) services, such as the <code>proxy</code>, if enabled, by running:</p> <pre><code>docker compose up -d\ndocker compose logs --tail 250 --follow\n</code></pre> <p>If you changed anything in the <code>.env</code> file while debugging, some containers might restart now; that's perfectly fine.</p>"},{"location":"migrate/v2.0/#7-verify","title":"7) Verify","text":"<p>With all services online, it's time to go to your browser and check everything is working.</p> <ol> <li>Upload and post a picture</li> <li>Comment on a post</li> <li>Like a post</li> <li>Check Horizon (<code>https://${APP_DOMAIN}/horizon</code>) for any errors</li> <li>Check the Docker compose logs via <code>docker compose logs --follow</code></li> </ol> <p>If everything looks fine, yay, you made it to the end! Let us do some cleanup</p>"},{"location":"migrate/v2.0/#8-cleanup","title":"8) Cleanup","text":"<p>With everything working, please take a new snapshot/backup of your server before we do any cleanup. A post-migration snapshot is handy since it contains both the old and new configuration + data, making any recovery much easier in a rollback scenario later.</p> <p>Now, with all the data in the new folders, you can delete the old Docker Container volumes (if you want, completely optional)</p> <p>List all volumes and give them a look:</p> <pre><code>docker volume ls\n</code></pre> <p>The volumes we want to delete end with the volume name (<code>db-data</code>, <code>app-storage</code>, <code>redis-data</code>, and <code>app-bootstrap</code>.) but have some prefixes in front of them.</p> <p>Once you have found the volumes in in the list, delete each of them by running:</p> <pre><code>docker volume rm $volume_name_in_column_two_of_the_output\n</code></pre> <p>You can also delete the <code>docker-compose.yml.old</code> and <code>.env.old</code> files since they are no longer needed:</p> <pre><code>rm docker-compose.yml.old\nrm .env.old\n</code></pre>"},{"location":"migrate/v2.0/#rollback","title":"Rollback","text":"<p>Oh no, something went wrong? No worries; you have backups and a quick way back!</p>"},{"location":"migrate/v2.0/#move-docker-composeyml-back","title":"Move <code>docker-compose.yml</code> back","text":"<pre><code>cp docker-compose.yml docker-compose.yml.new\ncp docker-compose.yml.old docker-compose.yml\n</code></pre>"},{"location":"migrate/v2.0/#move-env-file-back","title":"Move <code>.env</code> file back","text":"<pre><code>cp env.old .env\n</code></pre>"},{"location":"migrate/v2.0/#go-back-to-the-old-source-code-version","title":"Go back to the old source code version","text":"<pre><code>git checkout $commit_id_from_step_0\n</code></pre>"},{"location":"migrate/v2.0/#start-things-back-up","title":"Start things back up","text":"<pre><code>docker compose up -d\n</code></pre>"},{"location":"migrate/v2.0/#verify-it-worked","title":"Verify it worked","text":"<p>See Step 7 for recommended steps to verify everythin is working</p>"},{"location":"migrate/v3.0/","title":"v3 (jippi/docker-pixelfed)","text":"<p>This doc is WIP and may include wrong or incomplete information</p> <p>v2 to v3?!... oh no, not again!</p> <p>Docker Compose v2 was a huge change, requiring a lot of (risky) work to get migrated. v3 will be significantly smaller, and should largely be a drop-in experience, outside of some relatively simple cleanup/move-files-around tasks due to <code>docker-pixelfed</code> not being in the main source tree any more.</p> <p>Changes made from between the Docker Compose v2 version in upstream Pixelfed and this project.</p> <p>This document assume you are running Docker Compose v2 already and is looking to move to v3.</p>"},{"location":"migrate/v3.0/#breaking-changes","title":"Breaking Changes","text":"<p>These changes are breaking, removing, or changing existing behavior from Docker Compose v1 and requires your attention and possibly some steps to fix.</p>"},{"location":"migrate/v3.0/#breaking-change-new-docker-image-names","title":"Breaking Change New Docker image names","text":"<p>Since <code>docker-pixelfed</code> do not exist within the <code>pixelfed</code> project itself, the URL for the container images will change.</p> <p>Before you might have something like the following in your <code>.env</code> file</p> <pre><code>DOCKER_APP_DEBIAN_RELEASE=\"bullseye\"\nDOCKER_APP_IMAGE=\"ghcr.io/jippi/pixelfed\"\nDOCKER_APP_PHP_VERSION=\"8.2\"\nDOCKER_APP_RELEASE=\"jippi-fork-1\"\n</code></pre> <p>Those are now</p> <pre><code># [v0] for the least v0.x.y release of Pixelfed\n# [v0.12] for the least v0.12.x release of Pixelfed\n# [v0.12.1] for the v0.12.1 release of Pixelfed\nDOCKER_APP_RELEASE=\"v0.12.1\"\n\n# changed from ghcr.io/jippi/pixelfed\nDOCKER_APP_IMAGE=\"ghcr.io/jippi/docker-pixelfed\"\n\n# changed from \"bullseye\"\nDOCKER_APP_DEBIAN_RELEASE=\"bookworm\"\n\n# We only build PHP 8.3 now, so 8.2 or 8.1 is not supported\nDOCKER_APP_PHP_VERSION=\"8.3\"\n\n# Different format\nDOCKER_APP_TAG=\"${DOCKER_APP_RELEASE:?missing}-${DOCKER_APP_RUNTIME:?missing}-${DOCKER_APP_PHP_VERSION:?missing}-${DOCKER_APP_DEBIAN_RELEASE:?missing}\"\n</code></pre>"},{"location":"migrate/v3.0/#breaking-change-splitting-the-dockerfile","title":"Breaking Change Splitting the <code>Dockerfile</code>","text":"<p>v3 splits the Dockerfile into two to keep them focused, and reducing build times, by having higher cache utilization.</p> <ul> <li>One for the \"PHP\" container (package, source)<ul> <li>System packages</li> <li>PHP</li> <li>PECL extensions</li> <li>Composer</li> </ul> </li> <li>One for the <code>runtime</code> Pixelfed container (package, source)<ul> <li>Pixelfed Source Code</li> <li>Apache / nginx / FPM</li> <li>Docker Entrypoint (and it's scripts)</li> </ul> </li> </ul> <p>This should not directly impact most users, as any custom build you did before (custom PHP extensions, frontend, etc.) can still be done against the <code>runtime</code> Docker image.</p>"},{"location":"migrate/v3.0/#breaking-change-no-latest-tags","title":"Breaking Change No <code>latest</code> tags","text":"<p><code>latest</code> tags are typically pretty dangerous to use, especially in a fast-moving project such as Pixelfed where things might break in patch releases.</p> <p>Instead, we now offer the following tags</p> <ul> <li><code>v{major}-{runtime}-{php_version}</code><ul> <li>For example <code>v0-apache-8.3</code> will always point to the latest <code>0.x</code> release of Pixelfed, using PHP 8.3 and Apache.</li> <li>This tag is mutable when any new <code>0.x.y</code> release is created from Pixelfed (e.g. <code>0.15.4</code>).</li> <li>This tag is mutable if a new <code>docker-pixelfed</code> release is cut for any <code>0.x.y</code> Pixelfed release.</li> </ul> </li> <li><code>v{major}.{minor}-{runtime}-{php_version}</code><ul> <li>For example <code>v0.12-apache-8.3</code> will always point to the latest <code>0.12.x</code> release of Pixelfed, using PHP 8.3 and Apache.</li> <li>This tag is mutable when any new <code>0.12.x</code> release is created from Pixelfed (e.g. <code>0.12.4</code>).</li> <li>This tag is mutable if a new <code>docker-pixelfed</code> release is cut for any <code>0.12.x</code> Pixelfed release.</li> </ul> </li> <li><code>v{major}.{minor}.{patch}-{runtime}-{php_version}</code><ul> <li>For example <code>v0.12.1-apache-8.3</code>  will always point to the latest <code>0.12.1</code> release of Pixelfed, using PHP 8.3 and Apache.</li> <li>This tag is immutable to any Pixelfed code changes.</li> <li>This tag is mutable if a new <code>docker-pixelfed</code> release is cut for this Pixelfed release.</li> </ul> </li> <li><code>v{tag}</code><ul> <li>For example <code>v0.12.1-docker1-apache-8.3</code> will always point to exactly the <code>0.12.1</code> release of Pixelfed with <code>docker1</code> (this projects changes).</li> <li>This tag is immutable across Pixelfed and <code>docker-pixelfed</code> changes.</li> </ul> </li> </ul>"},{"location":"migrate/v3.0/#breaking-change-no-fpm-runtime","title":"Breaking Change No <code>fpm</code> runtime","text":"<p>v3 only builds <code>apache</code> (with <code>mod_php</code>) and <code>nginx</code> (with <code>fpm</code>) runtimes now.</p> <p>The <code>fpm</code> runtime was quite an edge-case, not likely to be relevant for majority of folks (reach out if you are missing this!)</p>"},{"location":"migrate/v3.0/#new-or-improved-features","title":"New or improved features","text":"<p>All the new and exciting features and capabilities. </p> <p>This is where we hope we can convince you that the breaking changes and migration work was worth it </p>"},{"location":"migrate/v3.0/#improvement-nightly-builds","title":"Improvement Nightly builds","text":"<p>We will now automatically create nightly builds of Pixelfed from the <code>dev</code> and <code>staging</code> branches.</p> <ul> <li><code>nightly-dev-{runtime}-{php_version}</code><ul> <li>Always points to the latest Pixelfed commit on <code>staging</code> at the time of building the image (~8am UTC).</li> <li>For example <code>nightly-dev-apache-8.3</code> will always point to the latest commit on <code>dev</code> branch on the most recent build date.</li> </ul> </li> <li><code>nightly-staging-{runtime}-{php_version}</code><ul> <li>Always points to the latest Pixelfed commit on <code>staging</code> at the time of building the image (~8am UTC).</li> <li>For example <code>nightly-staging-apache-8.3</code> will always point to the latest commit on <code>staging</code> branch on the most recent build date.</li> </ul> </li> <li><code>nightly-{YYYYMMDD}-dev-{runtime}-{php_version}</code><ul> <li>Points to the latest Pixelfed commit on <code>staging</code> at the specific date, at the time of building the image (~8am UTC).</li> <li>For example <code>nightly-20240501-dev-apache-8.3</code> will always point to the latest commit on <code>dev</code> branch at <code>2024-05-01</code> (May 1<sup>st</sup> 2024)</li> </ul> </li> <li><code>nightly-{YYYYMMDD}-staging-{runtime}-{php_version}</code><ul> <li>Points to the latest Pixelfed commit on <code>staging</code> at the specific date, at the time of building the image (~8am UTC).</li> <li>For example <code>nightly-20240501-staging-apache-8.3</code> will always point to the latest commit on <code>staging</code> branch at <code>2024-05-01</code> (May 1<sup>st</sup> 2024)</li> </ul> </li> </ul>"}]}